"""
Description:           This script is used to calculate  and save statistics of significance using two-way ANOVA. The
                       cut off level of alpha is specified in the variable "alpha". It applies Bonferroni correction and
                       identified those voxels for which dendritic length per voxel is affected by <Labor State> while
                       not being affected by <init Refs> and the two effects are not dependent.

Usage:                 python filterSignificantVoxels.py <dataXL> <outputBase>
                       <data XL>: string containing the path of the excel file generated by "generateRawDF.py"
                       outputBase: string, output XL file will be saved as "<outBase>.xlsx". It will contain the
                       following columns:
                       pVal(initRefs): p-value obtained from two-way ANOVA of <initRefs> affecting dendritic length
                       pVal(ls): p-Value obtained from two-way ANOVA of  <Labor State> affecting dendritic length
                       pVal(ls:initRefs): p-Value obtained from two-way ANOVA of the two effects above being dependent.
                       Difference of Means: difference of means of Forager and Newly Emerged morphology
                       voxel center: string representation of 3 member float tuple, reprensenting the voxel center to
                       which  each row correponds.
                       voxel size: value of voxel size used to divide the space containing the morphologies
                       Significant Difference: either 0 or 1, value of 1 indicates the conditions above are satisfied.
"""

import pandas as pd
import sys
from GJMorph.customStats import art_two_way_anova
import numpy as np

if __name__ == '__main__':

    assert len(sys.argv) == 3, 'Improper usage! Please use as \'python filterSignificantVoxels.py ' \
                               '<dataXL> <outputBase>\''

    dataXL = sys.argv[1]
    outBase = sys.argv[2]

    columnTempNames = {"voxel center": "vc",
                       "percentage neurite length": "nl",
                       "set name": "ls"}

    dataDF = pd.read_excel(dataXL, index_col=0)

    meanNLPerVoxel = dataDF.groupby("voxel center").mean()["percentage neurite length"].sort_index()

    # unstacking is required to fill up the sparse data with zeros
    indexedDF = dataDF.set_index(keys=["voxel size", 'voxel center', 'set name', 'expID', "initRefs"])
    pivotedDF = indexedDF.unstack(level=('set name', "initRefs", 'expID'), fill_value=0)
    dataFullDF = pivotedDF.stack(level=('set name', "initRefs", "expID")).reset_index()
    dataDFR = dataFullDF.rename(columns=columnTempNames)
    dataDFR_reordered = dataDFR.loc[:, ["vc", "ls", "initRefs", "nl"]]

    statsDF = pd.DataFrame()

    totalVCs = dataDFR_reordered["vc"].unique().shape[0]
    for vcInd, (vc, vcDF) in enumerate(dataDFR_reordered.groupby("vc")):
        print("Doing {}, Number {}/{}".format(vc, vcInd + 1, totalVCs))
        toAppend = pd.Series()
        toAppend["voxel center"] = vc
        toAppend["voxel size"] = dataDF["voxel size"].iloc[0]

        artRes = art_two_way_anova(vcDF.set_index("vc"))

        if not np.isnan(artRes[1]).any():

            toAppend["ART correctness"], (toAppend["pVal(ls)"],
            toAppend["pVal(initRefs)"], toAppend["pVal(ls:initRefs)"]) = artRes

            temp = vcDF.set_index("ls")
            toAppend["Difference in Mean TDL"] = \
                temp.loc["Forager", "nl"].mean() - temp.loc["Newly Emerged", "nl"].mean()
            toAppend["Mean TDL"] = meanNLPerVoxel[vc]
            toAppend["Normed Difference in Mean TDL"] = 100 * toAppend["Difference in Mean TDL"] / meanNLPerVoxel[vc]
            statsDF = statsDF.append(toAppend, ignore_index=True)

    alpha = 0.05
    bfCorrectedAlpha = alpha / dataDF["initRefs"].unique().shape[0]

    sigDifFunc = lambda x: (x["pVal(ls:initRefs)"] > alpha) and \
                           (x["pVal(ls)"] < bfCorrectedAlpha) and (x["pVal(initRefs)"] > alpha)

    statsDF["Significant Difference"] = statsDF.apply(sigDifFunc, axis=1)
    statsDF.to_excel("{}.xlsx".format(outBase))



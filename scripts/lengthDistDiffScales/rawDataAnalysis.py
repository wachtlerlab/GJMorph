"""
Description:              This script can run multiple analysis and generate plots using the data generated by
                          generateRawDF.py and filterSignificantVoxels.py. Each analysis is implemented as a function, which can be run
                          by using different command line switches (see Usage). See the documentation of each function.

Usage:                    TODO
"""

import pandas as pd
import sys
from GJMorph.matplotlibRCParams import mplPars
from matplotlib import pyplot as plt
import seaborn as sns
import numpy as np


def plotNLDistribution(rawDataXL, initRefStr, outputBase):
    """
    This function plots the distribution of Total Dendritic Length per voxel for the registration results of using
    <initRefStr> as initial references, but pooling across voxels and experiment IDs.
    :param rawDataXL: str, path of the excel file generated by generateRawDF.py
    :param initRefStr: str, indicating the pair of reference templates. Has the form
    "ref_<forager_experiment_ID>_ref_<ne_experiment_ID>"
    :param outputBase: str, the plot will be save in the file "<outputBase>.png"
    :return:
    """

    dataDF = pd.read_excel(rawDataXL, index_col=0)
    dataDF.rename(columns={"set name": "Labor State"}, inplace=True)

    if initRefStr == "all":
        subDataDF = dataDF
    elif initRefStr in dataDF["initRefs"].values:
        subDataDF = dataDF[dataDF["initRefs"] == initRefStr]
    else:
        raise ValueError("The initial reference string {} was not found in {}".format(initRefStr, rawDataXL))

    foragerData = dataDF[dataDF["Labor State"] == "Forager"]
    neData = dataDF[dataDF["Labor State"] == "Newly Emerged"]

    foragerNLMean = foragerData["neurite length"].mean()
    neNLMean = neData["neurite length"].mean()
    allNLMean = dataDF["neurite length"].mean()

    # mplPars["text.usetex"] = False
    sns.set(style="darkgrid", rc=mplPars)
    fig, ax = plt.subplots(figsize=(7, 5.6))

    sns.violinplot(x="neurite length", y="initRefs", data=subDataDF, hue="Labor State", split=True, scale="area",
                   inner="quartile", palette=["r", "b"], hue_order=["Newly Emerged", "Forager"], ax=ax, orient='h',
                   bw=0.001)
    ax.set_xticks(np.arange(0, 150, 10), minor=True)
    ax.set_xlim(-5, 150)
    ax.grid(True, axis="x", which="minor")
    ax.set_yticklabels([])
    ax.set_ylabel("Relative frequency\n of occurance")
    ax.set_xlabel("Dendritic Length\nper neuron per voxel ($\mu m$)")
    ax.legend(ncol=2, loc="upper center")
    ylim = ax.get_ylim()
    ax.text(55, ylim[0] + 0.3 * (ylim[1] - ylim[0]),
            "f\_NL\_mean: {:.3g}\nne\_NL\_mean: {:.3g}\nall\_NL\_mean: {:.3g}".format(foragerNLMean,
                                                                                neNLMean, allNLMean),
            va="top", ha="left")
    fig.tight_layout()
    fig.savefig("{}.png".format(outputBase), dpi=300)


def plotMeanDiffDistribution(filteredDataXL, outBase):
    """
    This function plots the distribution of differences between mean dendritic lengths of foragers and newly emerged
    per voxel.
    :param filteredDataXL: str, path of the excel file generated filterSignificantVoxels.py
    :param outBase: str, plot generated will be saved to "<outBase>.png"
    :return:
    """

    df = pd.read_excel(filteredDataXL, index_col=0)

    sns.set(style="darkgrid", rc=mplPars)
    fig, ax = plt.subplots(figsize=(7, 5.6))

    sns.violinplot(x="Difference of Means", data=df, scale="area",
                   inner="quartile", ax=ax, bw=0.001)
    ax.set_xlim(-55, 60)
    ax.set_ylabel("Relative frequency\nof occurance")
    ax.set_xlabel("Difference of mean TDL per voxel\nForager-NewlyEmerged ($\mu m$)")
    fig.tight_layout()
    fig.savefig("{}.png".format(outBase), dpi=300)


def plotNormedMeanDifferenceDist(rawDataXL, filteredDataXL, outBase):
    """
    This function calculates the average Total Dendritic Length per voxel across all morphologies and plots the
    distribution of differences in mean Total Dendritic Length expressed as a percentage of the calculated average

    :param rawDataXL: str, path of the file generated by generateRawDF.py
    :param filteredDataXL: str, path of the file generated by filteredSignificantVoxels.py
    :param outBase: str, the plot will be saved in "<outBase>.png"
    :return:
    """

    dataDF = pd.read_excel(rawDataXL, index_col=0)

    meanNLPerVoxel = dataDF.groupby("voxel center").mean()["neurite length"].sort_index()

    # avgTDL = dataDF["neurite length"].mean()

    filteredDF = pd.read_excel(filteredDataXL, index_col=0)

    filteredDF.set_index("voxel center", inplace=True)
    filteredDF.sort_index(inplace=True)
    filteredDF["Mean neurite length"] = meanNLPerVoxel.values
    filteredDF["Normalized Percentage Difference of Means"] = filteredDF.apply(
        lambda x: 100 * x["Difference of Means"] / x["Mean neurite length"], axis=1)

    # normalizedPCDifferenceInTDL = 100 * filteredDF["Difference of Means"] / avgTDL

    sns.set(style="darkgrid", rc=mplPars)
    fig, ax = plt.subplots(figsize=(7, 5.6))

    sns.violinplot(x=filteredDF["Normalized Percentage Difference of Means"], scale="area",
                   inner="quartile", ax=ax, bw=0.001)
    ax.set_ylabel("Relative frequency\nof occurance")
    ax.set_xlabel("Normalized Percentage Difference \nbetween mean TDL per voxel\nForager-NewlyEmerged")
    ax.set_xlim(-150, 150)
    ax.set_xticks(np.arange(-150, 200, 50))
    ax.set_xticklabels(["{}\%".format(x) for x in np.arange(-150, 200, 50)], rotation=90)
    fig.tight_layout()
    fig.savefig("{}.png".format(outBase), dpi=300)

    filteredDF.to_excel("{}_diffNormed.xlsx".format(outBase))


if __name__ == '__main__':

    assert len(sys.argv) in [4, 5], 'Improper usage! Please use as \npython {currPYFile} distNL ' \
                                    '<rawDataXL> <initRefStr> <outputBase> or\n' \
                                    'python {currPYFile} distMeanDiff <filteredXL> <outBase> or\n' \
                                    'python {currPYFile} distMeanDiffNormed <rawDataXL> <filteredXL> <outBase>'.format(
        currPYFile=sys.argv[0])

    if sys.argv[1] == "distNL":
        plotNLDistribution(*sys.argv[2:])
    elif sys.argv[1] == "distMeanDiff":
        plotMeanDiffDistribution(*sys.argv[2:])
    elif sys.argv[1] == "distMeanDiffNormed":
        plotNormedMeanDifferenceDist(*sys.argv[2:])
